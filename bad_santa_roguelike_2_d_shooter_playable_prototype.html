<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bad Santa ‚Äî Roguelike 2D Shooter (Prototype)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #0b0f14; }
    body { display:flex; align-items:center; justify-content:center; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #wrap { width:min(1100px, 96vw); }
    #topbar {
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      color:#d8e1ee; margin: 10px 0 8px;
    }
    .pill { padding: 6px 10px; border:1px solid #2a3545; border-radius: 999px; background:#0f1520; }
    #canvas {
      width:100%;
      aspect-ratio: 16/9;
      max-height: 76vh;
      background: #070a0f;
      border: 1px solid #2a3545;
      border-radius: 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,.35);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #help {
      margin: 10px 0 18px;
      color:#9bb0c9;
      font-size: 12px;
      line-height: 1.45;
    }
    #help code { color:#d8e1ee; }
    a { color:#a6d1ff; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="topbar">
      <div class="pill" id="status">Loading‚Ä¶</div>
      <div class="pill" id="meta">Meta: ‚Äî</div>
      <div class="pill" id="hint">Tip: Press <b>P</b> to pause</div>
    </div>
    <canvas id="canvas" width="960" height="540"></canvas>
    <div id="help">
      <b>Bad Santa</b> (prototype): procedurally generated houses, permadeath per run, and a persistent skill tree.
      <br/>
      <b>Controls</b>: <code>WASD</code> move ¬∑ <code>IJKL</code> aim ¬∑ <code>Space</code> shoot ¬∑ <code>Shift</code> dash ¬∑ <code>P</code> pause ¬∑ <code>Enter</code> interact/advance.
      <br/>
      <b>Goal</b>: clear the house, steal enough presents (üéÅ), then defeat the boss guarding the Christmas tree (üéÑ) to advance.
      <br/>
      <b>Meta progression</b>: after death/win you can spend <i>Ornaments</i> (üí†) on upgrades that persist across runs.
      <br/>
      <span style="opacity:.8">Everything here is code-generated ‚Äúpixel sprites‚Äù (no external assets). This is a solid foundation you can expand: real sprite sheets, more tile variety, better AI, item drops, status effects, and more bosses.</span>
    </div>
  </div>

<script>
(() => {
  // ------------------------------------------------------------
  // BAD SANTA ‚Äî single-file prototype (no external assets)
  // ------------------------------------------------------------

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  const statusEl = document.getElementById('status');
  const metaEl = document.getElementById('meta');

  // -----------------------------
  // Utilities / PRNG
  // -----------------------------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function randInt(rng, a, b){ return Math.floor(rng()*(b-a+1))+a; }
  function chance(rng, p){ return rng() < p; }
  function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }
  function norm2(x,y){ const m=Math.hypot(x,y)||1; return [x/m,y/m]; }

  // Mulberry32 ‚Äî small deterministic RNG
  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }

  // -----------------------------
  // Pixel sprites (procedural)
  // -----------------------------
  function createSprite(w, h, data, palette){
    return {
      w, h, data, palette,
      draw(px,py,scale,frame=0,flip=false){
        // tiny animation: frame shifts details
        const wobble = (frame%2===0) ? 0 : 1;
        for (let y=0;y<h;y++){
          for (let x=0;x<w;x++){
            const idx = data[y*w+x];
            if (!idx) continue;
            ctx.fillStyle = palette[idx];
            const xx = flip ? (w-1-x) : x;
            ctx.fillRect(
              Math.floor(px + (xx+wobble)*scale),
              Math.floor(py + y*scale),
              scale, scale
            );
          }
        }
      }
    };
  }

  // Legacy noise generator for props (presents, trees)
  function makeSprite(seed, w, h, palette, symmetry=true){
    const rng = mulberry32(seed);
    const data = new Uint8Array(w*h);
    const mid = Math.floor(w/2);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const xx = symmetry ? (x<mid ? x : w-1-x) : x;
        const n = rng();
        let v = 0;
        const cx = mid-0.5, cy = h*0.55;
        const d = Math.hypot(xx-cx, y-cy);
        const core = clamp(1 - d/(h*0.65), 0, 1);
        if (core > 0.25 && n < core*0.9) v = 2;
        if (core > 0.55 && n < core*0.6) v = 3;
        if (n < 0.06) v = 1;
        data[y*w + x] = v;
      }
    }
    return createSprite(w,h,data,palette);
  }

  // -----------------------------
  // Input
  // -----------------------------
  const keys = new Map();
  addEventListener('keydown', (e) => {
    if (["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault();
    keys.set(e.code, true);
    if(audio && !audio.initialized) audio.init();
  }, {passive:false});
  addEventListener('keyup', (e) => keys.set(e.code, false));

  function key(code){ return !!keys.get(code); }

  // -----------------------------
  // Meta progression (persistent)
  // -----------------------------
  const META_KEY = 'bad_santa_meta_v1';
  const defaultMeta = () => ({
    ornaments: 0,
    // Skill nodes (level 0..max)
    skills: {
      hp: 0,        // +10 max HP per level
      dmg: 0,       // +8% damage per level
      spd: 0,       // +6% speed per level
      reload: 0,    // -6% reload per level
      dash: 0       // +1 dash charge at max
    },
    // last seed for fun
    lastSeed: 123456
  });

  function loadMeta(){
    try {
      const raw = localStorage.getItem(META_KEY);
      if (!raw) return defaultMeta();
      const m = JSON.parse(raw);
      const base = defaultMeta();
      return {
        ornaments: Number.isFinite(m.ornaments) ? m.ornaments : base.ornaments,
        skills: { ...base.skills, ...(m.skills||{}) },
        lastSeed: Number.isFinite(m.lastSeed) ? m.lastSeed : base.lastSeed,
      };
    } catch { return defaultMeta(); }
  }
  function saveMeta(){ localStorage.setItem(META_KEY, JSON.stringify(meta)); }
  let meta = loadMeta();

  const SKILL_INFO = {
    hp:     { name: 'Tough Coat',  desc: '+10 Max HP',       max: 8, cost: (lv)=> 6 + lv*6 },
    dmg:    { name: 'Mean Spirit', desc: '+8% Damage',       max: 8, cost: (lv)=> 8 + lv*7 },
    spd:    { name: 'Sleigh Boots',desc: '+6% Move Speed',   max: 8, cost: (lv)=> 7 + lv*6 },
    reload: { name: 'Fast Hands',  desc: '-6% Reload Time',  max: 8, cost: (lv)=> 7 + lv*6 },
    dash:   { name: 'Dash Charge', desc: 'More dashes',      max: 3, cost: (lv)=> 12 + lv*12 },
  };

  // -----------------------------
  // World / level generation
  // -----------------------------
  const TILE = 12;               // tile size in pixels
  const MAP_W = 96;              // tiles
  const MAP_H = 54;              // tiles

  // tile ids
  const T = {
    VOID: 0,
    FLOOR: 1,
    WALL: 2,
    DOOR: 3,
    RUG: 4,
    GOLD: 5,
    MARBLE: 6
  };

  function levelTheme(level){
    // 5 Distinct Biomes
    // 1-2: Chinatown (Poor)
    // 3-5: Doomer Slavic Flat (Poor+)
    // 6-8: Midtown House (Middle)
    // 9-11: Dusk Hills Condo (Upper)
    // 12+: Rock Cliff Mansion (Rich)

    let wealthTier = 0;
    let biome = 'chinatown';
    let name = 'Chinatown Slum';
    let floor = '#1a1818';
    let wall = '#3e2723';
    let accent = '#d32f2f'; // red lanterns
    let special = T.FLOOR;

    if (level <= 2) {
        biome = 'chinatown';
        name = 'Chinatown Slum';
        floor = '#211a1a';
        wall = '#4e342e';
        accent = '#e53935';
        wealthTier = 0;
    } else if (level <= 5) {
        biome = 'slavic';
        name = 'Slavic Doomer Flat';
        floor = '#263238'; // concrete
        wall = '#37474f';
        accent = '#78909c';
        wealthTier = 1;
    } else if (level <= 8) {
        biome = 'midtown';
        name = 'Midtown House';
        floor = '#3e2723'; // wood
        wall = '#5d4037';
        accent = '#ffecb3';
        wealthTier = 2;
    } else if (level <= 11) {
        biome = 'dusk';
        name = 'Dusk Hills Condo';
        floor = '#eceff1'; // white/clean
        wall = '#cfd8dc';
        accent = '#00bcd4'; // cyan
        wealthTier = 3;
    } else {
        biome = 'mansion';
        name = 'Rock Cliff Mansion';
        floor = '#212121'; // dark marble
        wall = '#263238';
        accent = '#ffd700'; // gold
        special = T.MARBLE;
        wealthTier = 4;
    }

    // linear difficulty curve
    const t = clamp((level-1)/12, 0, 1);

    return {
      wealthTier,
      biome,
      name,
      floorColor: floor,
      wallColor: wall,
      accentColor: accent,
      specialFloor: special,
      decorRate: lerp(0.05, 0.25, t),
      targetRooms: Math.floor(lerp(12, 28, t)),
      enemyMul: lerp(0.8, 1.8, t),
      presentMul: lerp(0.8, 1.4, t),
      bossType: wealthTier, // 0..4
    };
  }

  function carveRoom(map, x,y,w,h, floorId){
    for (let yy=y; yy<y+h; yy++){
      for (let xx=x; xx<x+w; xx++){
        if (xx<=1||yy<=1||xx>=MAP_W-2||yy>=MAP_H-2) continue;
        map[yy*MAP_W + xx] = floorId;
      }
    }
  }

  function rectsOverlap(a,b){
    return !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);
  }

  function carveCorridor(map, ax,ay,bx,by, floorId){
    // L-shaped corridor (3 tiles wide for easier movement and style)
    const horizFirst = ((ax^ay^bx^by) & 1) === 0;
    const drawH = (x1,x2,y)=>{
      const s=Math.min(x1,x2), e=Math.max(x1,x2);
      for (let x=s; x<=e; x++){
        if (y-1 > 0) map[(y-1)*MAP_W+x]=floorId;
        map[y*MAP_W+x]=floorId;
        if (y+1 < MAP_H-1) map[(y+1)*MAP_W+x]=floorId;
      }
    };
    const drawV = (y1,y2,x)=>{
      const s=Math.min(y1,y2), e=Math.max(y1,y2);
      for (let y=s; y<=e; y++){
        if (x-1 > 0) map[y*MAP_W+(x-1)]=floorId;
        map[y*MAP_W+x]=floorId;
        if (x+1 < MAP_W-1) map[y*MAP_W+(x+1)]=floorId;
      }
    };
    if (horizFirst){
      drawH(ax,bx,ay);
      drawV(ay,by,bx);
    } else {
      drawV(ay,by,ax);
      drawH(ax,bx,by);
    }
  }

  function buildWalls(map){
    for (let y=1;y<MAP_H-1;y++){
      for (let x=1;x<MAP_W-1;x++){
        const i=y*MAP_W+x;
        if (map[i] !== T.VOID) continue;
        // any neighbor floor? become wall
        const n = [i-1,i+1,i-MAP_W,i+MAP_W,i-MAP_W-1,i-MAP_W+1,i+MAP_W-1,i+MAP_W+1];
        if (n.some(j => map[j]===T.FLOOR||map[j]===T.RUG||map[j]===T.GOLD||map[j]===T.MARBLE||map[j]===T.DOOR)) map[i]=T.WALL;
      }
    }
  }

  function placeDoors(map, rooms, rng){
    // Put doors where corridors meet rooms (simple heuristic)
    for (const r of rooms){
      for (let t=0;t<4;t++){
        const side = randInt(rng, 0, 3);
        let x,y;
        if (side===0){ x = randInt(rng, r.x+1, r.x+r.w-2); y=r.y; }
        if (side===1){ x = randInt(rng, r.x+1, r.x+r.w-2); y=r.y+r.h-1; }
        if (side===2){ x = r.x; y = randInt(rng, r.y+1, r.y+r.h-2); }
        if (side===3){ x = r.x+r.w-1; y = randInt(rng, r.y+1, r.y+r.h-2); }
        const i=y*MAP_W+x;
        if (map[i]!==T.FLOOR && map[i]!==T.RUG && map[i]!==T.GOLD && map[i]!==T.MARBLE) continue;
        // neighbor void on one side and floor on other -> door
        const nb = [
          map[i-1], map[i+1], map[i-MAP_W], map[i+MAP_W]
        ];
        const floorCount = nb.filter(v => v!==T.VOID && v!==T.WALL).length;
        const wallCount  = nb.filter(v => v===T.WALL).length;
        if (floorCount>=2 && wallCount>=1){ map[i]=T.DOOR; }
      }
    }
  }

  function farthestRoom(rooms, from){
    let best=rooms[0], bestD=-1;
    for (const r of rooms){
      const cx=r.x+Math.floor(r.w/2), cy=r.y+Math.floor(r.h/2);
      const d = (cx-from.x)*(cx-from.x)+(cy-from.y)*(cy-from.y);
      if (d>bestD){ bestD=d; best=r; }
    }
    return best;
  }

  function genHouse(seed, level){
    const rng = mulberry32(seed);
    const theme = levelTheme(level);

    const map = new Uint8Array(MAP_W*MAP_H);
    map.fill(T.VOID);

    const rooms = [];
    const attempts = 220;
    const minSize = 6 + theme.wealthTier;
    const maxSize = 14 + theme.wealthTier*4;

    for (let i=0;i<attempts && rooms.length<theme.targetRooms;i++){
      const w = randInt(rng, minSize, maxSize);
      const h = randInt(rng, minSize, maxSize);
      const x = randInt(rng, 2, MAP_W-w-3);
      const y = randInt(rng, 2, MAP_H-h-3);
      const room = {x,y,w,h};
      // allow some overlap but keep it light
      const overlaps = rooms.filter(r => rectsOverlap({x:x-2,y:y-2,w:w+4,h:h+4}, r)).length;
      if (overlaps>0 && chance(rng, 0.85)) continue;
      carveRoom(map, x,y,w,h, theme.specialFloor);
      rooms.push(room);
    }

    // Connect rooms
    rooms.sort((a,b)=> (a.x+a.y) - (b.x+b.y));
    for (let i=1;i<rooms.length;i++){
      const a=rooms[i-1], b=rooms[i];
      const ax=a.x+Math.floor(a.w/2), ay=a.y+Math.floor(a.h/2);
      const bx=b.x+Math.floor(b.w/2), by=b.y+Math.floor(b.h/2);
      carveCorridor(map, ax,ay,bx,by, theme.specialFloor);
    }

    // Rugs & decor tiles
    for (let y=2;y<MAP_H-2;y++){
      for (let x=2;x<MAP_W-2;x++){
        const i=y*MAP_W+x;
        if (map[i]!==theme.specialFloor) continue;
        if (chance(rng, theme.decorRate)) map[i]=T.RUG;
      }
    }

    buildWalls(map);
    placeDoors(map, rooms, rng);

    // Start in first room; tree + boss in farthest
    const startRoom = rooms[0] || {x:10,y:10,w:10,h:10};
    const sPos = { x: (startRoom.x+2)*TILE, y: (startRoom.y+2)*TILE };

    const far = farthestRoom(rooms, {x:startRoom.x, y:startRoom.y});
    const treeTile = { x: far.x+Math.floor(far.w/2), y: far.y+Math.floor(far.h/2) };

    return { seed, rng, theme, map, rooms, startPos: sPos, treeTile };
  }

  // -----------------------------
  // Entities
  // -----------------------------
  const ENT = {
    PLAYER: 'player',
    ENEMY: 'enemy',
    BOSS: 'boss',
    BULLET: 'bullet',
    PRESENT: 'present',
    ORNAMENT: 'ornament',
    TREE: 'tree',
    PROP: 'prop',
    POTION: 'potion',
    WEAPON: 'weapon',
    CANDY: 'candy',
    DECOR: 'decor'
  };

  function tileAt(world, tx, ty){
    if (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return T.WALL;
    return world.map[ty*MAP_W+tx];
  }
  function solidTile(t){ return t===T.WALL || t===T.VOID; }

  function isSolidAt(world, x,y){
    const tx = Math.floor(x/TILE), ty=Math.floor(y/TILE);
    return solidTile(tileAt(world, tx,ty));
  }

  function collideCircle(world, x,y,r, ents=[]){
    // test surrounding tiles
    const minx = Math.floor((x-r)/TILE), maxx=Math.floor((x+r)/TILE);
    const miny = Math.floor((y-r)/TILE), maxy=Math.floor((y+r)/TILE);
    for (let ty=miny; ty<=maxy; ty++){
      for (let tx=minx; tx<=maxx; tx++){
        const t = tileAt(world, tx,ty);
        if (!solidTile(t)) continue;
        const rx=tx*TILE, ry=ty*TILE;
        const cx=clamp(x, rx, rx+TILE);
        const cy=clamp(y, ry, ry+TILE);
        if (dist(x,y,cx,cy) <= r) return true;
      }
    }
    // test props
    for (const e of ents){
      if (e.type === ENT.PROP && !e.dead){
        // props are solid circles
        if (dist(x,y,e.x,e.y) <= (r+e.r)) return true;
      }
    }
    return false;
  }

  function tryMoveCircle(world, ent, dx,dy, ents=[]){
    const steps = 4;
    let okx=true, oky=true;
    for (let i=0;i<steps;i++){
      const sx=dx/steps, sy=dy/steps;
      if (!collideCircle(world, ent.x+sx, ent.y, ent.r, ents)) ent.x += sx; else okx=false;
      if (!collideCircle(world, ent.x, ent.y+sy, ent.r, ents)) ent.y += sy; else oky=false;
    }
    return okx || oky;
  }

  function makePlayerSprite(seed, theme){
    const w=12, h=16;
    const rng = mulberry32(seed);
    const data = new Uint8Array(w*h);
    // Palette: 0:void, 1:white, 2:red, 3:black/boots, 4:face
    const palette = {
      0:'rgba(0,0,0,0)',
      1:'#ffffff',
      2:'#d43b3b',
      3:'#1a1a1a',
      4:'#ffccaa'
    };
    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };

    const mid = Math.floor(w/2);
    // Legs
    fill(mid-2, 12, 2, 4, 3);
    fill(mid+1, 12, 2, 4, 3);
    // Body
    fill(mid-3, 7, 7, 5, 2);
    // Arms
    fill(mid-4, 7, 1, 4, 2);
    fill(mid+4, 7, 1, 4, 2);
    // Belt
    fill(mid-3, 10, 7, 1, 3);
    // Trim
    fill(mid, 7, 1, 5, 1);
    fill(mid-3, 11, 7, 1, 1);
    // Head
    fill(mid-2, 2, 5, 5, 4);
    // Beard
    for(let y=5; y<8; y++) for(let x=mid-2; x<=mid+2; x++) if(chance(rng,0.85)) data[y*w+x]=1;
    // Hat
    fill(mid-2, 0, 5, 2, 2);
    fill(mid-3, 2, 7, 1, 1);
    if(chance(rng,0.5)) data[0*w+mid+3]=1; else data[0*w+mid-3]=1; // pompom

    return createSprite(w, h, data, palette);
  }

  function makeEnemySprite(seed, theme){
    const rng = mulberry32(seed);
    const w=12, h=14;
    const data = new Uint8Array(w*h);
    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };
    const mid = Math.floor(w/2);

    // Biome specific palettes and shapes
    if (theme.biome === 'chinatown') {
        const type = rng() < 0.6 ? 0 : 1; // 0=Thug, 1=Tosser
        const palette = {0:'rgba(0,0,0,0)', 1:'#ffcc80', 2:'#d32f2f', 3:'#212121', 4:'#fbc02d'};
        // Thug: headband, tank top
        fill(mid-2,10,2,4,3); fill(mid+1,10,2,4,3); // legs
        fill(mid-3,6,7,4,2); // shirt
        fill(mid-1,2,3,4,1); // head
        fill(mid-2,2,5,1,3); // headband
        if(type===1) fill(mid-4,7,2,2,4); // bomb in hand
        return {sprite:createSprite(w,h,data,palette), ai: type===0 ? 'rush' : 'bomb'};

    } else if (theme.biome === 'slavic') {
        const type = rng() < 0.6 ? 0 : 1; // 0=Gopnik, 1=Bear
        if(type===0){
            const palette = {0:'rgba(0,0,0,0)', 1:'#ffd54f', 2:'#1565c0', 3:'#eceff1', 4:'#455a64'};
            fill(mid-2,10,2,4,2); fill(mid+1,10,2,4,2); // trackpants
            fill(mid-3,6,7,4,2); // trackjacket
            fill(mid,6,1,8,3); // stripe
            fill(mid-1,2,3,4,1); // head
            fill(mid-2,1,5,2,4); // flat cap
            return {sprite:createSprite(w,h,data,palette), ai: 'shoot'};
        } else {
            const palette = {0:'rgba(0,0,0,0)', 1:'#795548', 2:'#5d4037', 3:'#3e2723'};
            fill(mid-4,8,8,5,2); // body
            fill(mid-3,11,2,3,3); fill(mid+1,11,2,3,3); // legs
            fill(mid-2,4,5,4,2); // head
            fill(mid-3,3,2,2,2); fill(mid+2,3,2,2,2); // ears
            return {sprite:createSprite(w,h,data,palette), ai: 'tank'};
        }

    } else if (theme.biome === 'dusk') {
        const type = rng() < 0.5 ? 0 : 1;
        const palette = {0:'rgba(0,0,0,0)', 1:'#b0bec5', 2:'#ffffff', 3:'#29b6f6', 4:'#263238'};
        // Cyborg
        fill(mid-2,10,2,4,1); fill(mid+1,10,2,4,1);
        fill(mid-3,5,7,5,2); // white armor
        fill(mid-1,2,3,3,4); // helmet
        fill(mid,3,2,1,3); // visor
        return {sprite:createSprite(w,h,data,palette), ai: type===0 ? 'burst' : 'snipe'};

    } else if (theme.biome === 'mansion') {
        // Agent / Elite
        const palette = {0:'rgba(0,0,0,0)', 1:'#ffcc80', 2:'#212121', 3:'#fafafa', 4:'#333333'};
        fill(mid-2,10,2,4,2); fill(mid+1,10,2,4,2);
        fill(mid-3,6,7,4,2); // suit
        fill(mid-1,6,3,3,3); // shirt
        fill(mid,7,1,2,2); // tie
        fill(mid-1,2,3,4,1); // head
        fill(mid-2,2,5,1,4); // sunglasses
        return {sprite:createSprite(w,h,data,palette), ai: 'dash_shoot'};

    } else {
        // Midtown / Generic (Elf/Snowman legacy but upgraded look)
        const palette = {0:'rgba(0,0,0,0)', 1:'#ffffff', 2:'#66bb6a', 3:'#d43b3b', 4:'#333333'};
        fill(mid-2,11,2,3,3); fill(mid+1,11,2,3,3);
        fill(mid-3,6,7,5,2);
        fill(mid-1,2,3,4,1);
        fill(mid-2,1,5,2,3);
        return {sprite:createSprite(w,h,data,palette), ai: 'wander_shoot'};
    }
  }

  function generateBossName(theme, rng){
    const pre = {
      chinatown: ['Jade', 'Red', 'Iron', 'Golden', 'Shadow'],
      slavic: ['Boris', 'Ivan', 'General', 'Hard', 'Cold'],
      midtown: ['Manager', 'Angry', 'Big', 'Santa', 'The'],
      dusk: ['Cyber', 'Neon', 'Unit', 'Project', 'Tech'],
      mansion: ['Krampus', 'Dark', 'Lord', 'Saint', 'Grand']
    };
    const suf = {
      chinatown: ['Dragon', 'Tiger', 'Emperor', 'Monk', 'Lotus'],
      slavic: ['Bear', 'Hammer', 'Winter', 'Wolf', 'Tank'],
      midtown: ['Karen', 'Neighbor', 'Dad', 'Boss', 'Consumer'],
      dusk: ['Claus', 'Ghost', 'Zero', 'One', 'Spectre'],
      mansion: ['Father', 'Claus', 'Nicholas', 'Spirit', 'Demon']
    };
    const p = pre[theme.biome] || pre.midtown;
    const s = suf[theme.biome] || suf.midtown;
    return p[randInt(rng, 0, p.length-1)] + ' ' + s[randInt(rng, 0, s.length-1)];
  }

  function makeBossSprite(seed, theme){
    const rng = mulberry32(seed);
    const w=24, h=24;
    const data = new Uint8Array(w*h);
    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };
    const mid = Math.floor(w/2);

    if (theme.biome==='chinatown'){
        // Dragon Mask
        const palette = {0:'rgba(0,0,0,0)', 1:'#fbc02d', 2:'#d32f2f', 3:'#212121', 4:'#ffffff'};
        fill(mid-5,8,10,10,2); // body
        fill(mid-6,4,12,6,1); // mask
        fill(mid-4,5,2,2,4); fill(mid+2,5,2,2,4); // eyes
        fill(mid-6,0,3,4,3); fill(mid+3,0,3,4,3); // horns
        return createSprite(w, h, data, palette);

    } else if (theme.biome==='slavic'){
        // Heavy Weapons Bear
        const palette = {0:'rgba(0,0,0,0)', 1:'#795548', 2:'#4e342e', 3:'#212121', 4:'#cfd8dc'};
        fill(mid-6,14,4,8,3); fill(mid+2,14,4,8,3); // boots
        fill(mid-7,6,14,10,2); // fur body
        fill(mid-8,8,3,6,4); // gun arm
        fill(mid-4,2,8,6,1); // head
        fill(mid-5,1,3,3,2); fill(mid+2,1,3,3,2); // ears
        return createSprite(w, h, data, palette);

    } else if (theme.biome==='dusk'){
        // CEO Mech
        const palette = {0:'rgba(0,0,0,0)', 1:'#eceff1', 2:'#78909c', 3:'#00bcd4', 4:'#263238'};
        fill(mid-5,12,10,10,4); // legs
        fill(mid-7,4,14,10,1); // chassis
        fill(mid-3,6,6,4,3); // core window
        fill(mid-8,2,4,8,2); fill(mid+4,2,4,8,2); // shoulder mounts
        return createSprite(w, h, data, palette);

    } else if (theme.biome==='mansion'){
        // Bad Santa / Krampus
        const palette = {0:'rgba(0,0,0,0)', 1:'#b71c1c', 2:'#212121', 3:'#ffeb3b', 4:'#ffffff'};
        fill(mid-5,12,10,10,2); // robe bottom
        fill(mid-6,4,12,10,1); // robe top
        fill(mid-2,1,4,4,3); // crown/horns
        fill(mid-3,4,6,4,4); // beard
        fill(mid-8,6,3,8,1); fill(mid+5,6,3,8,1); // arms
        return createSprite(w, h, data, palette);

    } else {
        // Midtown / Generic Boss (Big Brute)
        const palette = {0:'rgba(0,0,0,0)', 1:'#5d4037', 2:'#8d6e63', 3:'#3e2723', 4:'#ff5722'};
        fill(mid-5,14,4,8,3); fill(mid+1,14,4,8,3); // legs
        fill(mid-7,5,14,9,2); // body
        fill(mid-3,1,6,5,1); // head
        fill(mid-2,2,1,1,4); fill(mid+1,2,1,1,4); // glowing eyes
        return createSprite(w, h, data, palette);
    }
  }

  function makePresentSprite(seed){
    const w=10, h=10;
    const data = new Uint8Array(w*h);
    const rng = mulberry32(seed);
    const palette = {
      0:'rgba(0,0,0,0)',
      1:'#ffffff', // ribbon
      2:'#ef5350', // box red
      3:'#d32f2f', // box dark red
      4:'#42a5f5', // box blue
      5:'#1565c0', // box dark blue
      6:'#66bb6a', // box green
      7:'#2e7d32'  // box dark green
    };
    // Pick a color pair
    const colorSet = randInt(rng, 0, 2); // 0=red, 1=blue, 2=green
    const main = 2 + colorSet*2;
    const dark = 3 + colorSet*2;
    const rib = 1;

    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };

    // Box
    fill(1, 2, 8, 8, main);
    // Shading/Outline
    fill(1, 9, 8, 1, dark);
    fill(8, 2, 1, 8, dark);

    // Ribbon Vertical
    fill(4, 2, 2, 8, rib);
    // Ribbon Horizontal
    fill(1, 5, 8, 2, rib);

    // Bow
    fill(3, 0, 1, 2, rib);
    fill(6, 0, 1, 2, rib);
    fill(2, 1, 1, 1, rib);
    fill(7, 1, 1, 1, rib);

    return createSprite(w, h, data, palette);
  }

  function makeTreeSprite(seed){
    const w=16, h=18;
    const data = new Uint8Array(w*h);
    const rng = mulberry32(seed);
    const palette = {
      0:'rgba(0,0,0,0)',
      1:'#2e7d32', // dark green
      2:'#4caf50', // light green
      3:'#795548', // trunk
      4:'#fdd835', // star/light
      5:'#e53935', // orn red
      6:'#42a5f5'  // orn blue
    };
    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };

    const mid = Math.floor(w/2); // 8

    // Trunk
    fill(mid-1, 14, 3, 4, 3);

    // Layers
    // Bottom
    for(let y=10; y<15; y++){
        const width = 14 - (y-10)*2; // 14, 12, 10, 8, 6
        const start = mid - Math.floor(width/2);
        fill(start, y, width, 1, 1);
    }
    // Middle
    for(let y=6; y<11; y++){
        const width = 10 - (y-6)*2; // 10, 8, 6, 4, 2
        const start = mid - Math.floor(width/2);
        fill(start, y, width, 1, 1);
    }
    // Top
    for(let y=2; y<7; y++){
        const width = 6 - (y-2)*2; // 6, 4, 2
        const start = mid - Math.floor(width/2);
        fill(start, y, width, 1, 1);
    }

    // Add highlights (tips of branches)
    for(let y=2; y<15; y++){
        for(let x=0; x<w; x++){
            if(data[y*w+x]===1 && chance(rng, 0.3)) data[y*w+x]=2;
        }
    }

    // Star
    fill(mid, 0, 1, 2, 4);
    fill(mid-1, 1, 3, 1, 4);

    // Ornaments
    for(let i=0; i<8; i++){
        const y = randInt(rng, 3, 14);
        const x = randInt(rng, 2, 13);
        if(data[y*w+x] === 1 || data[y*w+x] === 2){
            data[y*w+x] = chance(rng, 0.5) ? 5 : 6;
        }
    }

    return createSprite(w, h, data, palette);
  }

  function makePotionSprite(seed){
    const w=8, h=10;
    const data = new Uint8Array(w*h);
    const palette = {
      0:'rgba(0,0,0,0)',
      1:'#ffffff', // highlight
      2:'#ff4081', // pink liquid
      3:'#f48fb1', // light pink
      4:'#eeeeee'  // glass/cork
    };
    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };
    const mid = Math.floor(w/2);
    // Neck
    fill(mid-1, 0, 2, 3, 4);
    // Cork
    fill(mid-1, 0, 2, 1, 1);
    // Bulb
    fill(1, 3, 6, 6, 4); // glass outline/bg
    fill(2, 4, 4, 4, 2); // liquid
    fill(3, 4, 2, 2, 3); // liquid highlight
    fill(5, 5, 1, 1, 1); // glint

    return createSprite(w, h, data, palette);
  }

  function makeCandySprite(seed){
    const w=8, h=8;
    const data = new Uint8Array(w*h);
    const palette = {
      0:'rgba(0,0,0,0)',
      1:'#ffffff', // white
      2:'#d32f2f', // red
      3:'#c62828'  // dark red
    };
    const rng = mulberry32(seed);
    const type = rng() < 0.5 ? 0 : 1; // 0=cane, 1=wrapped
    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };

    if (type===0){ // Candy Cane
       // simple hook shape
       fill(2,1,4,1,2);
       fill(1,2,1,2,1);
       fill(5,2,1,5,2);
       // stripes
       fill(5,3,1,1,1);
       fill(5,5,1,1,1);
    } else { // Wrapped Candy
       fill(2,2,4,4,2); // center
       fill(0,1,2,2,1); // left wing
       fill(6,5,2,2,1); // right wing
       fill(3,3,2,2,3); // detail
    }
    return createSprite(w, h, data, palette);
  }

  function makeWeaponSprite(seed, kind){
    // kind: 0=shotgun, 1=uzi, 2=sniper
    const w=16, h=8;
    const data = new Uint8Array(w*h);
    const palette = {
      0:'rgba(0,0,0,0)',
      1:'#ffffff',
      2:'#555555', // metal
      3:'#222222', // grip
      4: (kind===0 ? '#8d6e63' : kind===1 ? '#333333' : '#2e7d32') // wood/black/camo
    };
    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };

    if (kind===0){ // Shotgun
      fill(0,2,14,3,2); // barrel
      fill(2,5,6,2,4); // stock
      fill(8,5,2,3,3); // grip
    } else if (kind===1){ // Uzi
      fill(4,1,8,4,2); // body
      fill(6,5,2,3,3); // grip
      fill(12,2,2,2,2); // muzzle
    } else { // Sniper
      fill(0,3,16,2,2); // long barrel
      fill(2,5,4,2,4); // stock
      fill(6,1,4,2,3); // scope
    }
    return createSprite(w,h,data,palette);
  }

  function makeFurnitureSprite(type, seed){
    const rng = mulberry32(seed);
    // types: 0=table, 1=chair, 2=bed, 3=plant
    if (type===0){ // Table
      const w=14, h=10;
      const data = new Uint8Array(w*h);
      const palette = {0:'rgba(0,0,0,0)', 1:'#5d4037', 2:'#795548', 3:'#3e2723'};
      const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };
      fill(1,2,w-2,6,2); // top
      fill(2,3,w-4,4,1); // inner
      fill(1,8,2,2,3); fill(w-3,8,2,2,3); // legs
      fill(1,2,1,6,3); fill(w-2,2,1,6,3); // sides
      return createSprite(w,h,data,palette);
    } else if (type===1){ // Chair
      const w=8, h=12;
      const data = new Uint8Array(w*h);
      const palette = {0:'rgba(0,0,0,0)', 1:'#5d4037', 2:'#8d6e63', 3:'#3e2723'};
      const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };
      fill(1,6,6,4,2); // seat
      fill(1,0,1,6,1); fill(6,0,1,6,1); // back
      fill(2,1,4,1,1); fill(2,3,4,1,1); // slats
      fill(1,10,1,2,3); fill(6,10,1,2,3); // legs
      return createSprite(w,h,data,palette);
    } else if (type===2){ // Bed
      const w=14, h=18;
      const data = new Uint8Array(w*h);
      const palette = {0:'rgba(0,0,0,0)', 1:'#d32f2f', 2:'#e57373', 3:'#ffffff', 4:'#3e2723'};
      const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };
      fill(1,1,12,16,4); // frame
      fill(2,4,10,12,2); // sheet
      fill(2,4,10,3,3); // pillow area
      fill(2,2,10,2,3); // pillows
      fill(2,10,10,5,1); // blanket
      return createSprite(w,h,data,palette);
    } else { // Plant
      const w=10, h=14;
      const data = new Uint8Array(w*h);
      const palette = {0:'rgba(0,0,0,0)', 1:'#2e7d32', 2:'#4caf50', 3:'#795548', 4:'#3e2723'};
      const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };
      fill(2,9,6,5,3); // pot
      fill(2,9,6,1,4); // rim
      // leaves
      for(let i=0;i<12;i++){
        const x = randInt(rng, 0, w-2);
        const y = randInt(rng, 0, 8);
        data[y*w+x] = (i%2==0) ? 1 : 2;
        data[(y+1)*w+x+1] = (i%2==0) ? 1 : 2;
      }
      return createSprite(w,h,data,palette);
    }
  }

  function makeDecorSprite(theme, type, seed){
    const rng = mulberry32(seed);
    // type: 'rug', 'window', 'clutter'
    const w=16, h=16; // default
    let data = new Uint8Array(w*h);
    let palette = {0:'rgba(0,0,0,0)'};
    const fill = (x,y,W,H,c) => { for(let iy=y;iy<y+H;iy++) for(let ix=x;ix<x+W;ix++) if(ix>=0&&ix<w&&iy>=0&&iy<h) data[iy*w+ix]=c; };
    const mid = Math.floor(w/2);

    if (type === 'rug'){
      // Rugs should be roughly tile size (12x12) or larger?
      const ww=12, hh=12;
      const p = {0:'rgba(0,0,0,0)'};
      if (theme.biome === 'chinatown'){
        p[1]='#b71c1c'; p[2]='#e65100'; // red/orange
        fill(2,2,ww,hh,1);
        fill(3,3,ww-2,hh-2,2);
        fill(4,4,ww-4,hh-4,1);
        fill(6,6,4,4,2);
      } else if (theme.biome === 'slavic'){
        p[1]='#4e342e'; p[2]='#3e2723'; // brown/dark
        fill(2,2,ww,hh,1);
        // worn spots
        for(let i=0;i<10;i++) data[randInt(rng,2,13)*16+randInt(rng,2,13)]=0;
        fill(3,3,ww-2,hh-2,2);
      } else if (theme.biome === 'midtown'){
         p[1]='#3f51b5'; p[2]='#7986cb'; // blue
         fill(2,2,ww,hh,1);
         fill(3,3,ww-2,hh-2,2);
         // stripes
         fill(5,2,2,hh,1); fill(9,2,2,hh,1);
      } else if (theme.biome === 'dusk'){
        p[1]='#263238'; p[2]='#cfd8dc'; // metal grate
        fill(2,2,ww,hh,1);
        for(let y=2;y<14;y+=2) fill(2,y,ww,1,2);
      } else { // mansion
        p[1]='#4a148c'; p[2]='#880e4f'; // royal purple/red
        fill(2,2,ww,hh,1);
        fill(3,3,ww-2,hh-2,2);
        // gold trim
        p[3]='#ffd700';
        fill(2,2,ww,1,3); fill(2,13,ww,1,3); fill(2,2,1,hh,3); fill(13,2,1,hh,3);
      }
      return createSprite(16,16,data,p);

    } else if (type === 'window'){
      const ww=10, hh=12;
      // Windows are on North walls.
      const p = {0:'rgba(0,0,0,0)'};
      if (theme.biome === 'chinatown'){
         p[1]='#3e2723'; p[2]='#ffecb3'; // wood/light
         // Circle window or lattice
         fill(3,2,10,10,1); // frame
         fill(4,3,8,8,2); // light
         fill(4,7,8,1,1); // bars
         fill(7,3,1,8,1);
      } else if (theme.biome === 'slavic'){
         p[1]='#424242'; p[2]='#90a4ae'; // grey/dim light
         fill(3,2,10,8,1);
         fill(4,3,8,6,2);
         fill(5,3,1,4,0); // crack
      } else if (theme.biome === 'midtown'){
          p[1]='#5d4037'; p[2]='#81d4fa'; // wood/sky
          fill(3,2,10,10,1);
          fill(4,3,8,8,2);
          fill(4,7,8,1,1);
          fill(8,3,1,8,1);
          // curtains
          p[3]='#e57373';
          fill(2,2,3,10,3); fill(11,2,3,10,3);
      } else if (theme.biome === 'dusk'){
          p[1]='#263238'; p[2]='#00bcd4'; // dark/neon
          fill(3,4,10,2,1);
          fill(4,5,8,1,2); // neon slit
      } else { // mansion
          p[1]='#3e2723'; p[2]='#fff59d'; // dark wood/warm light
          fill(3,0,10,14,1); // tall
          fill(4,1,8,12,2);
          fill(8,1,1,12,1);
      }
      return createSprite(16,16,data,p);

    } else if (type === 'clutter'){
        // Random small items
        const item = randInt(rng, 0, 2);
        const p = {0:'rgba(0,0,0,0)', 1:'#ffffff', 2:'#757575'};
        if (item===0){ // Papers
           fill(6,6,3,4,1);
           fill(7,7,1,2,2);
        } else if (item===1){ // Bottle/Can
           p[3]='#ef5350';
           fill(7,6,2,4,3);
           fill(7,5,2,1,2);
        } else { // Stain
           p[1]='#3e2723';
           fill(5,6,6,4,1);
        }
        return createSprite(16,16,data,p);
    }
    return createSprite(16,16,data,palette);
  }

  // -----------------------------
  // Audio
  // -----------------------------
  const audio = {
    ctx: null,
    nextNoteTime: 0,
    noteIndex: 0,
    initialized: false,

    init(){
      if(this.initialized) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if(!Ctx) return;
      this.ctx = new Ctx();
      this.initialized = true;
      this.playMusic();
    },

    playTone(freq, type, dur, vol=0.1){
      if(!this.ctx) return;
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
      gain.gain.setValueAtTime(vol, this.ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      osc.start();
      osc.stop(this.ctx.currentTime + dur);
    },

    playNoise(dur, vol=0.1){
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * dur;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },

    playWeaponShoot(kind){
       if(!this.ctx) return;

       if (kind === 'shotgun'){
           // Heavy boom + noise
           this.playNoise(0.25, 0.35);
           this.playTone(100, 'sawtooth', 0.15, 0.2); // Low punch
           this.playTone(55, 'square', 0.3, 0.25);    // Sub
       } else if (kind === 'uzi'){
           // Fast, sharp
           this.playNoise(0.06, 0.12);
           this.playTone(400, 'square', 0.06, 0.1);
       } else if (kind === 'sniper'){
           // Loud, long decay
           this.playNoise(0.15, 0.3);
           this.playTone(900, 'triangle', 0.05, 0.2); // Crack
           this.playTone(120, 'sawtooth', 0.4, 0.35); // Body
       } else {
           // Pistol (default)
           this.playNoise(0.1, 0.2);
           this.playTone(220, 'sawtooth', 0.12, 0.1);
       }
    },

    playStep(){
       if(!this.ctx) return;
       this.playNoise(0.05, 0.05);
    },

    playMusic(){
       if(!this.ctx) return;
       // We'll schedule ahead
       setInterval(() => this.scheduler(), 100);
    },

    scheduler(){
       if(!this.ctx) return;
       const tempo = 140; // BPM
       const secondsPerBeat = 60.0 / tempo;
       const lookahead = 0.1; // seconds

       while (this.nextNoteTime < this.ctx.currentTime + lookahead) {
           // Determine biome from global game object if available
           let biome = 'midtown';
           if (typeof game !== 'undefined' && game && game.world && game.world.theme) {
               biome = game.world.theme.biome;
           }

           this.playMusicForBiome(biome, this.nextNoteTime, this.noteIndex);
           this.nextNoteTime += secondsPerBeat * 0.5; // eighth notes
           this.noteIndex++;
       }
    },

    playMusicForBiome(biome, time, index){
       // Scales
       const pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00]; // C D E G A
       const minor = [220, 246.94, 261.63, 293.66, 329.63, 349.23, 392.00]; // A Minor

       // Helper: play a simple pluck
       const pluck = (freq, type, vol, dur) => {
           const osc = this.ctx.createOscillator();
           const gain = this.ctx.createGain();
           osc.type = type;
           osc.frequency.value = freq;
           gain.gain.setValueAtTime(vol, time);
           gain.gain.exponentialRampToValueAtTime(0.001, time + dur);
           osc.connect(gain);
           gain.connect(this.ctx.destination);
           osc.start(time);
           osc.stop(time + dur);
       };

       // Helper: bass note with filter
       const bass = (freq, type, vol, dur, cutoff=300) => {
           const osc = this.ctx.createOscillator();
           const gain = this.ctx.createGain();
           const filter = this.ctx.createBiquadFilter();
           osc.type = type;
           osc.frequency.value = freq;
           filter.type = 'lowpass';
           filter.frequency.value = cutoff;
           gain.gain.setValueAtTime(vol, time);
           gain.gain.exponentialRampToValueAtTime(0.001, time + dur);
           osc.connect(filter);
           filter.connect(gain);
           gain.connect(this.ctx.destination);
           osc.start(time);
           osc.stop(time + dur);
       };

       if (biome === 'chinatown') {
           // Pentatonic, generative plucked strings
           // Pattern length 32
           const i = index % 32;
           // Melody: somewhat random but pentatonic
           if (i % 2 === 0 && Math.random() < 0.8) { // 8th notes
               // Use a pseudo-random index based on time to keep it deterministic-ish but long
               const n = Math.floor(Math.sin(index * 0.3) * 5 + 5) % 5;
               const octave = (index % 16 < 8) ? 1 : 2;
               pluck(pentatonic[n] * octave, 'triangle', 0.08, 0.4);
           }
           // Bass drone
           if (i === 0) {
               bass(130.81, 'triangle', 0.15, 3.0); // C3
           }
       } else if (biome === 'slavic') {
           // Post-punk Doomer
           // Driving 8th note bass
           const bassNotes = [73.42, 73.42, 73.42, 73.42, 65.41, 65.41, 87.31, 82.41]; // D, C, F, E
           const bi = Math.floor(index / 8) % 8;
           bass(bassNotes[bi], 'sawtooth', 0.12, 0.3, 400);

           // Melancholy lead (sparse)
           if (index % 16 === 12) {
              const lead = [293.66, 349.23, 293.66, 261.63]; // D F D C
              const li = Math.floor(index / 64) % 4;
              pluck(lead[li] * 2, 'square', 0.05, 0.6);
           }
       } else if (biome === 'dusk') {
           // Synthwave / Arp
           // Arpeggio: Root-5-8-5
           const root = 146.83; // D3
           const arp = [1, 1.5, 2, 1.5]; // 1, 5, 8, 5
           const ai = index % 4;
           if (index % 2 === 0) {
              pluck(root * arp[ai], 'sawtooth', 0.06, 0.2);
           }
           // Pad swell every 32
           if (index % 32 === 0) {
               bass(73.42, 'sine', 0.2, 4.0, 800);
           }
       } else if (biome === 'mansion') {
           // Dark Orchestral
           // Slow chords
           const chord = [220, 261.63, 329.63]; // Am
           const chord2 = [207.65, 246.94, 311.13]; // G#dim ?? or E major

           if (index % 64 === 0) {
               chord.forEach(f => bass(f, 'sawtooth', 0.05, 6.0, 400));
               bass(110, 'sawtooth', 0.1, 6.0, 200);
           }
           if (index % 64 === 32) {
               chord2.forEach(f => bass(f, 'sawtooth', 0.05, 6.0, 400));
               bass(103.83, 'sawtooth', 0.1, 6.0, 200);
           }
           // Bell
           if (index % 16 === 0 && Math.random() > 0.3) {
               pluck(880, 'sine', 0.05, 1.0);
           }
       } else {
           // Midtown / Default
           // Carol of the Bells style but extended
           // Motif: Bb, A, Bb, G => F#, F, F#, D
           const motif = [370, 349.23, 370, 293.66];
           const m = index % 4;
           // Vary motif every 16 bars
           const section = Math.floor(index / 64) % 3; // 0, 1, 2

           if (section === 0) {
               pluck(motif[m], 'triangle', 0.06, 0.3);
           } else if (section === 1) {
               // Harmony thirds up
               pluck(motif[m] * 1.25, 'triangle', 0.05, 0.3);
           } else {
               // Bass + Motif
               pluck(motif[m], 'triangle', 0.06, 0.3);
               if (m===0) bass(73.42, 'sawtooth', 0.1, 1.0);
           }
       }
    }
  };

  // -----------------------------
  // Game state
  // -----------------------------
  let game = null;

  const WEAPON_MAP = ['shotgun', 'uzi', 'sniper'];

  function createGun(kind, run){
    const baseDmg = 12 * run.baseStats.damageMul;
    if (kind === 'shotgun') {
        return {
            kind: 'shotgun',
            reload: 0,
            reloadMax: 0.55 * run.baseStats.reloadMul, // slow
            spread: 0.35,
            bulletSpeed: 290,
            damage: baseDmg * 0.7, // lower per bullet
            count: 5 // 5 bullets
        };
    } else if (kind === 'uzi') {
        return {
            kind: 'uzi',
            reload: 0,
            reloadMax: 0.08 * run.baseStats.reloadMul, // very fast
            spread: 0.22,
            bulletSpeed: 340,
            damage: baseDmg * 0.6, // low damage
            count: 1
        };
    } else if (kind === 'sniper') {
        return {
            kind: 'sniper',
            reload: 0,
            reloadMax: 0.9 * run.baseStats.reloadMul, // very slow
            spread: 0.01,
            bulletSpeed: 480,
            damage: baseDmg * 3.5, // high damage
            count: 1
        };
    }
    // Default Pistol
    return {
        kind: 'pistol',
        reload: 0,
        reloadMax: 0.18 * run.baseStats.reloadMul,
        spread: 0.08,
        bulletSpeed: 320,
        damage: baseDmg,
        count: 1
    };
  }

  function applyMetaToBaseStats(){
    const hpLv = meta.skills.hp|0;
    const dmgLv = meta.skills.dmg|0;
    const spdLv = meta.skills.spd|0;
    const relLv = meta.skills.reload|0;
    const dashLv= meta.skills.dash|0;

    return {
      maxHp: 60 + hpLv*10,
      damageMul: 1 + dmgLv*0.08,
      speedMul: 1 + spdLv*0.06,
      reloadMul: 1 - relLv*0.06,
      dashCharges: 1 + Math.floor(dashLv/2),
      dashCooldownMul: 1 - dashLv*0.06,
    };
  }

  function startNewRun(seed){
    const rng = mulberry32(seed);
    const baseStats = applyMetaToBaseStats();

    const run = {
      seed,
      rng,
      level: 1,
      ornamentsEarnedThisRun: 0,
      paused: false,
      mode: 'play', // 'play' | 'between' | 'dead' | 'win'
      msg: '',
      time: 0,
      baseStats,
      // camera
      camX: 0,
      camY: 0,
      // aim vector
      aimX: 1,
      aimY: 0,
      // kill / loot requirements
      presentsNeeded: 0,
      presentsTaken: 0,
      enemiesRemaining: 0,
      bossAlive: true,
      // entities
      ents: [],
      bullets: [],
      particles: [],
      // world
      world: null,
      // UI selection in meta shop
      shopIndex: 0,
      // Inventory
      inventory: ['pistol'],
      weaponIdx: 0,
    };

    loadLevel(run, 1);
    game = run;
    updateMetaUI();
  }

  function addEnt(run, e){ run.ents.push(e); return e; }

  function spawnLevel(run, level, hpOverride=null){
    const seed = (run.seed ^ (level*0x9E3779B9)) >>> 0;
    const world = genHouse(seed, level);
    const rng = world.rng;

    run.world = world;
    run.ents = [];
    run.bullets = [];
    run.particles = [];
    run.time = 0;
    run.msg = '';
    run.mode = 'play';

    const theme = world.theme;

    const startHp = (typeof hpOverride === 'number') ? hpOverride : run.baseStats.maxHp;

    // 1. Decor (Rugs, Windows, Clutter)
    // Needs to be before player for Z-order (rendered first = behind)

    // Rugs from map
    for (let y=0;y<MAP_H;y++){
      for (let x=0;x<MAP_W;x++){
        if (tileAt(world,x,y)===T.RUG){
           // spawn decor
           const sprite = makeDecorSprite(theme, 'rug', (seed+x*y)>>>0);
           addEnt(run, { type: ENT.DECOR, x:(x+0.5)*TILE, y:(y+0.5)*TILE, r:0, sprite, frame:0 });
           // reset tile to floor to keep it walkable and have background color
           world.map[y*MAP_W+x] = theme.specialFloor;
        }
      }
    }

    // Windows (North walls)
    // Scan walls: if map[y][x] is WALL and map[y+1][x] is FLOOR (or special floor)
    for (let y=1;y<MAP_H-1;y++){
      for (let x=1;x<MAP_W-1;x++){
        const t = tileAt(world, x,y);
        const tDown = tileAt(world, x,y+1);
        if (t===T.WALL && (tDown===T.FLOOR || tDown===T.GOLD || tDown===T.MARBLE || tDown===theme.specialFloor)){
           if (chance(rng, 0.3)){
              const sprite = makeDecorSprite(theme, 'window', (seed+x*37+y)>>>0);
              // offset y slightly to align with wall face
              addEnt(run, { type: ENT.DECOR, x:(x+0.5)*TILE, y:(y+0.5)*TILE, r:0, sprite, frame:0 });
           }
        }
      }
    }

    // Clutter on floors
    for (const r of world.rooms){
       const n = randInt(rng, 0, Math.floor(r.w*r.h*0.05));
       for(let k=0;k<n;k++){
         const tx = randInt(rng, r.x+1, r.x+r.w-2);
         const ty = randInt(rng, r.y+1, r.y+r.h-2);
         const x=(tx+0.5)*TILE, y=(ty+0.5)*TILE;
         // avoid start/tree
         if (dist(x,y,world.startPos.x, world.startPos.y)<60) continue;
         if (dist(x,y,(world.treeTile.x+0.5)*TILE, (world.treeTile.y+0.5)*TILE)<60) continue;

         const sprite = makeDecorSprite(theme, 'clutter', (seed+k*99+tx)>>>0);
         addEnt(run, { type: ENT.DECOR, x, y, r:0, sprite, frame:0 });
       }
    }

    // Player
    const pSprite = makePlayerSprite((seed+1)>>>0, theme);
    const player = addEnt(run, {
      type: ENT.PLAYER,
      x: world.startPos.x,
      y: world.startPos.y,
      r: 6,
      hp: startHp,
      maxHp: run.baseStats.maxHp,
      speed: 96 * run.baseStats.speedMul,
      dash: {
        charges: run.baseStats.dashCharges,
        maxCharges: run.baseStats.dashCharges,
        cd: 0,
        cdMax: 0.9 * (1/run.baseStats.dashCooldownMul)
      },
      // weapon from inventory
      gun: createGun(run.inventory ? run.inventory[run.weaponIdx] : 'pistol', run),
      invuln: 0,
      frame: 0,
      flip: false,
      sprite: pSprite,
    });
    run.player = player;

    // Tree & boss room
    const treeX = (world.treeTile.x + 0.5) * TILE;
    const treeY = (world.treeTile.y + 0.5) * TILE;
    const treeSprite = makeTreeSprite((seed+222)>>>0);
    addEnt(run, { type: ENT.TREE, x: treeX, y: treeY, r: 10, sprite: treeSprite, frame: 0 });

    // Props (furniture)
    for (const r of world.rooms){
      // skip start and boss rooms to avoid clutter there
      if ((r.x+Math.floor(r.w/2)===world.treeTile.x && r.y+Math.floor(r.h/2)===world.treeTile.y) ||
          (Math.abs(r.x*TILE - world.startPos.x)<100 && Math.abs(r.y*TILE - world.startPos.y)<100)) continue;

      const count = randInt(rng, 1, Math.floor(r.w*r.h/20));
      for(let k=0; k<count; k++){
         const type = randInt(rng, 0, 3); // 0=table, 1=chair, 2=bed, 3=plant
         const tx = randInt(rng, r.x+1, r.x+r.w-2);
         const ty = randInt(rng, r.y+1, r.y+r.h-2);
         const x=(tx+0.5)*TILE, y=(ty+0.5)*TILE;

         // simple collision check against other props/entities would be good but minimal works
         if (dist(x,y,player.x,player.y)<40) continue;

         const sprite = makeFurnitureSprite(type, (seed + r.x + k*55)>>>0);
         addEnt(run, { type: ENT.PROP, x, y, r: 6, sprite, frame:0, hp: 15, dead:false });
      }
    }

    // Potions (Rare)
    if (chance(rng, 0.4)){
      const room = world.rooms[randInt(rng, 0, world.rooms.length-1)];
      const x = (randInt(rng, room.x+1, room.x+room.w-2)+0.5)*TILE;
      const y = (randInt(rng, room.y+1, room.y+room.h-2)+0.5)*TILE;
      if (dist(x,y,player.x,player.y)>60){
         addEnt(run, { type: ENT.POTION, x, y, r: 6, sprite: makePotionSprite(seed), frame:0 });
      }
    }

    // Weapons (Rare)
    if (chance(rng, 0.35)){
      const room = world.rooms[randInt(rng, 0, world.rooms.length-1)];
      const x = (randInt(rng, room.x+1, room.x+room.w-2)+0.5)*TILE;
      const y = (randInt(rng, room.y+1, room.y+room.h-2)+0.5)*TILE;
      if (dist(x,y,player.x,player.y)>60){
         const kind = randInt(rng, 0, 2); // 0=shotgun, 1=uzi, 2=sniper
         addEnt(run, { type: ENT.WEAPON, x, y, r: 8, sprite: makeWeaponSprite(seed, kind), kind, frame:0 });
      }
    }

    // Presents
    const presentCount = Math.floor((10 + level*3) * theme.presentMul);
    run.presentsNeeded = Math.max(6, Math.floor(presentCount * 0.65));
    run.presentsTaken = 0;

    for (let i=0;i<presentCount;i++){
      const room = world.rooms[randInt(rng, 0, Math.max(0,world.rooms.length-1))] || {x:10,y:10,w:10,h:10};
      const tx = randInt(rng, room.x+2, room.x+room.w-3);
      const ty = randInt(rng, room.y+2, room.y+room.h-3);
      const x=(tx+0.5)*TILE, y=(ty+0.5)*TILE;
      if (dist(x,y,player.x,player.y)<80) continue;
      const sprite = makePresentSprite((seed + i*31)>>>0);
      addEnt(run, { type: ENT.PRESENT, x,y, r: 6, sprite, frame: 0 });
    }

    // Enemies
    const baseEnemies = Math.floor((14 + level*6) * theme.enemyMul);
    run.enemiesRemaining = 0;

    for (let i=0;i<baseEnemies;i++){
      const room = world.rooms[randInt(rng, 0, Math.max(0,world.rooms.length-1))] || {x:20,y:20,w:10,h:10};
      const tx = randInt(rng, room.x+2, room.x+room.w-3);
      const ty = randInt(rng, room.y+2, room.y+room.h-3);
      const x=(tx+0.5)*TILE, y=(ty+0.5)*TILE;
      if (dist(x,y,player.x,player.y)<120) continue;
      if (dist(x,y,treeX,treeY)<110) continue;

      const {sprite, ai} = makeEnemySprite((seed + 9000 + i*17)>>>0, theme);
      addEnt(run, {
        type: ENT.ENEMY,
        x,y,
        r: 6,
        hp: 20 + level*5,
        speed: (62 + level*3) * (1 + theme.wealthTier*0.06),
        atkCd: randInt(rng, 40, 90)/100,
        atkTimer: randInt(rng, 0, 50)/100,
        damage: 8 + Math.floor(level*0.6),
        frame: 0,
        flip: false,
        sprite,
        ai: ai || 'chase',
        mood: 'chase',
        wx: x,
        wy: y,
      });
      run.enemiesRemaining++;
    }

    // Boss
    const bossType = theme.bossType;
    const bossSeed = (seed ^ 0xB055) >>> 0;
    const bossSprite = makeBossSprite(bossSeed, theme);
    const bossName = generateBossName(theme, rng);

    // spawn boss safely inside room bounds
    const far = world.rooms.find(r => r.x+Math.floor(r.w/2) === world.treeTile.x && r.y+Math.floor(r.h/2) === world.treeTile.y) || {x:world.treeTile.x-4, y:world.treeTile.y-4, w:8, h:8};
    const bossX = clamp(treeX + 60, (far.x+1.5)*TILE, (far.x+far.w-1.5)*TILE);
    const bossY = treeY;

    const boss = addEnt(run, {
      type: ENT.BOSS,
      x: bossX,
      y: bossY,
      r: 12,
      hp: 220 + level*60,
      hpMax: 220 + level*60,
      speed: 52 + bossType*10,
      phase: 0,
      timer: 0,
      frame: 0,
      flip: false,
      sprite: bossSprite,
      kind: bossType, // 0..3
      name: bossName
    });

    run.boss = boss;
    run.bossAlive = true;

    // Ensure no starting collisions
    for (let t=0;t<50;t++){
      if (!collideCircle(world, player.x, player.y, player.r, run.ents)) break;
      player.x += 8; player.y += 8;
    }

    return run;
  }

  function loadLevel(run, level, hpOverride=null){
    run.level = level;
    spawnLevel(run, level, hpOverride);
  }

  function addOrnaments(run, n){
    run.ornamentsEarnedThisRun += n;
  }

  // -----------------------------
  // Combat
  // -----------------------------
  function shoot(run){
    const p = run.player;
    if (p.gun.reload>0) return;

    const rng = run.rng;
    const spread = p.gun.spread;
    const baseAngle = Math.atan2(run.aimY, run.aimX);
    const count = p.gun.count || 1;

    for(let k=0; k<count; k++){
        // for shotgun, spread is per bullet
        const a = baseAngle + (rng()*2-1)*spread;
        const vx = Math.cos(a), vy = Math.sin(a);

        run.bullets.push({
          x: p.x + vx*10,
          y: p.y + vy*10,
          vx: vx * p.gun.bulletSpeed,
          vy: vy * p.gun.bulletSpeed,
          r: 2,
          life: 0.9,
          dmg: p.gun.damage,
          from: ENT.PLAYER
        });
    }

    // muzzle flash particles
    for (let i=0;i<4;i++){
      const sp = 70 + run.rng()*90;
      const aa = baseAngle + (run.rng()*2-1)*0.7;
      run.particles.push({x:p.x+Math.cos(baseAngle)*12, y:p.y+Math.sin(baseAngle)*12, vx:Math.cos(aa)*sp, vy:Math.sin(aa)*sp, life:0.18});
    }

    p.gun.reload = p.gun.reloadMax;
  }

  function enemyShoot(run, e){
    const p = run.player;
    const dx = p.x - e.x, dy = p.y - e.y;
    const [nx,ny] = norm2(dx,dy);

    run.bullets.push({
      x: e.x + nx*10,
      y: e.y + ny*10,
      vx: nx * (220 + run.level*10),
      vy: ny * (220 + run.level*10),
      r: 2,
      life: 1.2,
      dmg: e.damage,
      from: ENT.ENEMY
    });
  }

  function bossAttack(run, b, dt){
    const p = run.player;
    b.timer += dt;

    const dx = p.x - b.x, dy = p.y - b.y;
    const [nx,ny] = norm2(dx,dy);

    // Basic shooting for all bosses (separate from special attacks)
    b.shootTimer = (b.shootTimer||0) - dt;
    if (b.shootTimer <= 0) {
      b.shootTimer = (b.kind === 0) ? 1.5 : (b.kind === 1) ? 1.2 : 0.9;
      // simple shot at player
      const a = Math.atan2(ny,nx);
      run.bullets.push({x:b.x, y:b.y, vx:Math.cos(a)*200, vy:Math.sin(a)*200, r:3, life:1.5, dmg: 8+run.level, from: ENT.BOSS});
    }

    // Boss kinds map to wealthTier 0..4
    // 0=Chinatown (Dragon), 1=Slavic (Bear), 2=Midtown (Brute), 3=Dusk (Mech), 4=Mansion (Santa)

    if (b.kind===0){ // Chinatown: Dragon Dash + Firecrackers
      if (b.timer>1.8){
        b.timer = 0;
        b.phase = 1; b.chargeT = 0;
        b.cx = nx; b.cy = ny;
        // Firecracker toss
        for(let k=0; k<6; k++){
            const a = run.rng()*Math.PI*2;
            const sp = 80 + run.rng()*60;
            run.bullets.push({x:b.x, y:b.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, r:4, life:2.0, dmg: 8+run.level, from: ENT.BOSS});
        }
      }
      if (b.phase===1){
        b.chargeT += dt;
        const sp = 300;
        tryMoveCircle(run.world, b, b.cx*sp*dt, b.cy*sp*dt, run.ents);
        if (b.chargeT>0.4){ b.phase=0; }
      }
    } else if (b.kind===1){ // Slavic: Minigun Spin
      if (b.timer>0.15){ // rapid fire state
        b.timer=0;
        b.spin = (b.spin||0) + 0.4;
        const a = b.spin;
        // 2-way stream
        run.bullets.push({x:b.x, y:b.y, vx:Math.cos(a)*240, vy:Math.sin(a)*240, r:2, life:1.4, dmg: 6+run.level, from: ENT.BOSS});
        run.bullets.push({x:b.x, y:b.y, vx:Math.cos(a+Math.PI)*240, vy:Math.sin(a+Math.PI)*240, r:2, life:1.4, dmg: 6+run.level, from: ENT.BOSS});
      }
    } else if (b.kind===2){ // Midtown: Triple Shot + Shockwave
      if (b.timer>1.4){
        b.timer=0;
        const a = Math.atan2(ny,nx);
        for (const off of [-0.25, 0, 0.25]){
          const aa=a+off;
          run.bullets.push({x:b.x, y:b.y, vx:Math.cos(aa)*260, vy:Math.sin(aa)*260, r:3, life:1.4, dmg: 10+run.level, from: ENT.BOSS});
        }
        // shockwave ring
        if(chance(run.rng, 0.4)){
            for(let i=0; i<12; i++){
                const aa = (i/12)*Math.PI*2;
                run.bullets.push({x:b.x, y:b.y, vx:Math.cos(aa)*120, vy:Math.sin(aa)*120, r:2, life:0.8, dmg: 8+run.level, from: ENT.BOSS});
            }
        }
      }
    } else if (b.kind===3){ // Dusk Hills: Laser/Snipe
       if (b.timer>2.0){
           b.timer=0;
           // accurate high speed shot
           const a = Math.atan2(ny,nx);
           run.bullets.push({x:b.x, y:b.y, vx:Math.cos(a)*500, vy:Math.sin(a)*500, r:4, life:1.5, dmg: 20+run.level*2, from: ENT.BOSS});
           // flankers
           for (const off of [-0.6, 0.6]){
             const aa=a+off;
             run.bullets.push({x:b.x, y:b.y, vx:Math.cos(aa)*200, vy:Math.sin(aa)*200, r:2, life:1.8, dmg: 8+run.level, from: ENT.BOSS});
           }
       }
    } else { // Mansion (Santa): Summon + Chaos
      if (b.timer>1.6){
        b.timer=0;
        const action = run.rng();
        if (action < 0.4){
          // summon elites
          for (let i=0;i<2;i++){
            const a = run.rng()*Math.PI*2;
            const ex = b.x + Math.cos(a)*40;
            const ey = b.y + Math.sin(a)*40;
            const {sprite, ai} = makeEnemySprite(((run.world.seed + 9999 + i*71 + run.time*10)>>>0), run.world.theme);
            addEnt(run, { type: ENT.ENEMY, x:ex, y:ey, r:6, hp: 25+run.level*5, speed: 80+run.level*4, atkCd:0.9, atkTimer:0.2, damage: 10+run.level, frame:0, flip:false, sprite, ai:ai||'chase', mood:'chase', wx:ex, wy:ey });
            run.enemiesRemaining += 1;
          }
        } else {
          // chaos volley
          for (let k=0;k<16;k++){
            const aa = run.rng()*Math.PI*2;
            run.bullets.push({x:b.x, y:b.y, vx:Math.cos(aa)*(180+run.rng()*100), vy:Math.sin(aa)*(180+run.rng()*100), r:3, life:1.2, dmg: 10+run.level, from: ENT.BOSS});
          }
        }
      }
    }

    // gentle pursue
    const sp = (b.speed) * (b.hp < b.hpMax*0.5 ? 1.15 : 1.0);
    tryMoveCircle(run.world, b, nx*sp*dt, ny*sp*dt, run.ents);
  }

  function hurt(run, target, dmg){
    if (target.type===ENT.PLAYER){
      if (target.invuln>0) return;
      target.hp -= dmg;
      target.invuln = 0.28;
      // hit particles
      for (let i=0;i<10;i++){
        const a = run.rng()*Math.PI*2;
        const sp = 50 + run.rng()*140;
        run.particles.push({x:target.x, y:target.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:0.25});
      }
      if (target.hp<=0){
        run.mode='dead';
        run.msg='You died. (Permadeath)';
      }
    } else {
      target.hp -= dmg;
      for (let i=0;i<6;i++){
        const a = run.rng()*Math.PI*2;
        const sp = 40 + run.rng()*120;
        run.particles.push({x:target.x, y:target.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:0.22});
      }
      if (target.hp<=0){
        // drop ornaments
        const drop = target.type===ENT.BOSS ? (10 + run.level*3) : 1;
        addOrnaments(run, drop);
        // also drop 0-2 present shards
        const n = target.type===ENT.BOSS ? 0 : (chance(run.rng, 0.25) ? 1 : 0);
        for (let i=0;i<n;i++){
          addEnt(run, { type: ENT.ORNAMENT, x:target.x+(run.rng()*2-1)*8, y:target.y+(run.rng()*2-1)*8, r:5, life: 8 });
        }

        // drop candy (5% chance)
        if (chance(run.rng, 0.05)){
           addEnt(run, { type: ENT.CANDY, x:target.x, y:target.y, r: 4, sprite: makeCandySprite((run.time*100)>>>0), frame: 0 });
        }

        if (target.type===ENT.ENEMY) run.enemiesRemaining = Math.max(0, run.enemiesRemaining-1);
        if (target.type===ENT.BOSS) run.bossAlive = false;

        target.dead = true;
      }
    }
  }

  // -----------------------------
  // Update loop
  // -----------------------------
  let last = performance.now();

  function update(){
    const now = performance.now();
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    if (!game){ requestAnimationFrame(update); return; }

    if (key('KeyP')){ // edge detect
      if (!game._pDown){
        game._pDown = true;
        game.paused = !game.paused;
      }
    } else game._pDown = false;

    if (game.paused){
      render(game);
      requestAnimationFrame(update);
      return;
    }

    step(game, dt);
    render(game);

    requestAnimationFrame(update);
  }

  function step(run, dt){
    run.time += dt;

    // Global mode transitions
    if (run.mode==='dead' || run.mode==='win'){
      // allow enter to go to meta shop / restart
      if (key('Enter') && !run._enterDown){
        run._enterDown = true;
        // bank ornaments and go to shop screen
        meta.ornaments += run.ornamentsEarnedThisRun;
        meta.lastSeed = run.seed;
        saveMeta();
        run.ornamentsEarnedThisRun = 0;
        run.mode = 'between';
        run.shopIndex = 0;
      }
      if (!key('Enter')) run._enterDown = false;
      return;
    }

    if (run.mode==='between'){
      stepShop(run, dt);
      return;
    }

    // Play mode
    const world = run.world;
    const p = run.player;

    // Aim with IJKL
    let ax=0, ay=0;
    if (key('KeyI')) ay -= 1;
    if (key('KeyK')) ay += 1;
    if (key('KeyJ')) ax -= 1;
    if (key('KeyL')) ax += 1;
    if (ax!==0 || ay!==0){
      const [nx,ny] = norm2(ax,ay);
      run.aimX = nx; run.aimY = ny;
      p.flip = (nx<0);
    }

    // Movement
    let mx=0,my=0;
    if (key('KeyW')) my -= 1;
    if (key('KeyS')) my += 1;
    if (key('KeyA')) mx -= 1;
    if (key('KeyD')) mx += 1;

    if (mx!==0||my!==0){
      const [nx,ny]=norm2(mx,my);
      tryMoveCircle(world, p, nx*p.speed*dt, ny*p.speed*dt, run.ents);
      p.frame = (p.frame + dt*10) % 4;
      if (nx!==0) p.flip = nx<0;

      // Step sound (throttled)
      p.stepTimer = (p.stepTimer||0) - dt;
      if (p.stepTimer <= 0) {
          audio.playStep();
          p.stepTimer = 0.3;
      }
    } else {
      p.frame = (p.frame + dt*2) % 4;
    }

    // Dash
    p.dash.cd = Math.max(0, p.dash.cd - dt);
    if (p.dash.charges < p.dash.maxCharges && p.dash.cd<=0){
      // recharge
      p.dash.charges += 1;
      p.dash.cd = p.dash.cdMax;
    }

    if (key('ShiftLeft') || key('ShiftRight')){
      if (!run._shiftDown){
        run._shiftDown = true;
        if (p.dash.charges>0 && (mx!==0||my!==0)){
          p.dash.charges -= 1;
          const [nx,ny]=norm2(mx,my);
          for (let i=0;i<10;i++){
            tryMoveCircle(world, p, nx*22, ny*22, run.ents);
          }
          p.invuln = Math.max(p.invuln, 0.20);
        }
      }
    } else run._shiftDown = false;

    // Weapon Switching
    if (key('KeyQ') && !run._qDown){
      run._qDown = true;
      if (run.inventory.length > 1){
        run.weaponIdx = (run.weaponIdx + 1) % run.inventory.length;
        const newKind = run.inventory[run.weaponIdx];
        p.gun = createGun(newKind, run);
        run.msg = 'Switched to: ' + newKind.toUpperCase();
      }
    } else if (!key('KeyQ')) run._qDown = false;

    // Shooting
    p.gun.reload = Math.max(0, p.gun.reload - dt);
    if (key('Space')){
      shoot(run);
      if(p.gun.reload === p.gun.reloadMax) audio.playWeaponShoot(p.gun.kind);
    }

    p.invuln = Math.max(0, p.invuln - dt);

    // Bullets
    for (const b of run.bullets){
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      b.life -= dt;
      if (collideCircle(world, b.x,b.y,b.r)) b.life = 0;

      // hit entities
      if (b.life>0){
        for (const e of run.ents){
          if (e.dead) continue;
          if (b.from===ENT.PLAYER && (e.type===ENT.ENEMY || e.type===ENT.BOSS || e.type===ENT.PROP)){
            if (dist(b.x,b.y,e.x,e.y) <= (b.r+e.r)){
              hurt(run, e, b.dmg);
              b.life=0;
              break;
            }
          }
          // Enemy bullets hitting props
          if ((b.from===ENT.ENEMY || b.from===ENT.BOSS) && e.type===ENT.PROP){
             if (dist(b.x,b.y,e.x,e.y) <= (b.r+e.r)){
               hurt(run, e, b.dmg);
               b.life=0;
               break;
             }
          }
          if ((b.from===ENT.ENEMY || b.from===ENT.BOSS) && e.type===ENT.PLAYER){
            if (dist(b.x,b.y,e.x,e.y) <= (b.r+e.r)){
              hurt(run, e, b.dmg);
              b.life=0;
              break;
            }
          }
        }
      }
    }
    run.bullets = run.bullets.filter(b => b.life>0);

    // Enemies AI
    for (const e of run.ents){
      if (e.dead) continue;
      if (e.type===ENT.ENEMY){
        e.frame = (e.frame + dt*6) % 4;

        const d = dist(e.x,e.y,p.x,p.y);

        // AI Behaviors
        // rush: moves fast towards player, melee only (collide damage), no shoot
        // bomb: maintains range, throws bombs
        // shoot: standard shoot/move
        // tank: slow, lots of hp, shoot
        // burst: burst fire
        // snipe: long range, slow fire, high accuracy
        // dash_shoot: dashes occasionally

        let moveSpd = e.speed;
        let shootRange = 260;
        let maintainDist = 0;

        if (e.ai === 'rush') {
            shootRange = 0; // no shooting
            maintainDist = 0;
            moveSpd *= 1.3;
        } else if (e.ai === 'bomb') {
            shootRange = 240;
            maintainDist = 180;
        } else if (e.ai === 'snipe') {
            shootRange = 450;
            maintainDist = 350;
            moveSpd *= 0.7;
        } else if (e.ai === 'tank') {
            moveSpd *= 0.6;
        }

        if (d < shootRange + 100){ e.mood='chase'; }
        if (d > shootRange + 200 && chance(run.rng, 0.01)) e.mood='wander';

        if (e.mood==='wander'){
          if (dist(e.x,e.y,e.wx,e.wy) < 12 || chance(run.rng, 0.01)){
            e.wx = e.x + (run.rng()*2-1)*140;
            e.wy = e.y + (run.rng()*2-1)*140;
          }
          const [nx,ny]=norm2(e.wx-e.x, e.wy-e.y);
          tryMoveCircle(world, e, nx*moveSpd*dt, ny*moveSpd*dt, run.ents);
          if (nx!==0) e.flip = nx<0;
        } else {
          // Chase / Combat
          let mx=0, my=0;
          if (maintainDist > 0) {
             if (d < maintainDist) { mx = -(p.x-e.x); my = -(p.y-e.y); } // back away
             else if (d > maintainDist+40) { mx = p.x-e.x; my = p.y-e.y; } // approach
          } else {
             mx = p.x-e.x; my = p.y-e.y;
          }

          if (mx!==0 || my!==0){
             const [nx,ny]=norm2(mx,my);
             tryMoveCircle(world, e, nx*moveSpd*dt, ny*moveSpd*dt, run.ents);
             if (nx!==0) e.flip = nx<0;
          }

          // Attack
          e.atkTimer -= dt;
          if (shootRange > 0 && e.atkTimer<=0 && d<shootRange){
            e.atkTimer = e.atkCd;
            if (e.ai === 'burst') {
                for(let k=0; k<3; k++) setTimeout(()=> !e.dead && enemyShoot(run,e), k*100);
                e.atkTimer += 0.5;
            } else if (e.ai === 'bomb') {
                // throw grenade (arcing bullet)
                const dx = p.x - e.x, dy = p.y - e.y;
                const [nx,ny] = norm2(dx,dy);
                run.bullets.push({x:e.x, y:e.y, vx:nx*180, vy:ny*180, r:4, life:1.2, dmg:e.damage*1.5, from:ENT.ENEMY});
            } else {
                enemyShoot(run, e);
            }
          }

          // Melee damage logic is handled in collision or if entity touches player?
          // Currently bullets do dmg. We should add body contact damage for 'rush' enemies.
          if (e.ai === 'rush' && dist(e.x,e.y,p.x,p.y) < (e.r+p.r+2)){
             hurt(run, p, 15*dt); // continuous damage contact
          }
        }
      }

      if (e.type===ENT.BOSS){
        e.frame = (e.frame + dt*4) % 4;
        bossAttack(run, e, dt);
      }

      if (e.type===ENT.ORNAMENT){
        e.life -= dt;
        // magnet to player
        const d = dist(e.x,e.y,p.x,p.y);
        if (d<120){
          const [nx,ny]=norm2(p.x-e.x, p.y-e.y);
          e.x += nx*180*dt;
          e.y += ny*180*dt;
        }
        if (d < (p.r+e.r+2)){
          addOrnaments(run, 1);
          e.dead = true;
        }
      }

      if (e.type===ENT.POTION){
        if (dist(e.x,e.y,p.x,p.y) < (p.r+e.r+4)){
          p.hp = Math.min(p.maxHp, p.hp + p.maxHp*0.5);
          run.msg = 'Drank Potion: Restored 50% HP';
          e.dead = true;
        }
      }

      if (e.type===ENT.CANDY){
        if (dist(e.x,e.y,p.x,p.y) < (p.r+e.r+4)){
          p.hp = Math.min(p.maxHp, p.hp + p.maxHp*0.05);
          run.msg = 'Ate Candy: Restored 5% HP';
          e.dead = true;
        }
      }

      if (e.type===ENT.WEAPON){
        if (dist(e.x,e.y,p.x,p.y) < (p.r+e.r+4)){
          const kindStr = WEAPON_MAP[e.kind]; // 0=shotgun, etc
          if (!run.inventory.includes(kindStr)){
             run.inventory.push(kindStr);
          }
          // auto equip
          run.weaponIdx = run.inventory.indexOf(kindStr);
          p.gun = createGun(kindStr, run);
          run.msg = 'Picked up: ' + kindStr.toUpperCase();
          e.dead = true;
        }
      }

      if (e.type===ENT.PRESENT){
        e.frame = (e.frame + dt*3) % 4;
        if (dist(e.x,e.y,p.x,p.y) < (p.r+e.r+2)){
          run.presentsTaken += 1;
          addOrnaments(run, 1);
          e.dead = true;
        }
      }

      if (e.type===ENT.TREE){
        e.frame = (e.frame + dt*2) % 4;
        // interaction if conditions met
        if (dist(e.x,e.y,p.x,p.y) < (p.r+e.r+8)){
          const okPresents = run.presentsTaken >= run.presentsNeeded;
          const okEnemies  = run.enemiesRemaining <= 0;
          const okBoss     = !run.bossAlive;
          if (okPresents && okEnemies && okBoss){
            run.msg = 'The tree is yours. Press Enter to go to the next house.';
            if (key('Enter') && !run._enterDown){
              run._enterDown = true;
              run.level += 1;
              // win condition at level 12
              if (run.level>12){
                run.mode='win';
                run.msg='You cleared the grand mansion. Bad Santa wins. (Enter)';
              } else {
                // Pass current HP to next level
                loadLevel(run, run.level, run.player.hp);
              }
            }
          } else {
            const parts = [];
            if (!okPresents) parts.push(`steal presents ${run.presentsTaken}/${run.presentsNeeded}`);
            if (!okEnemies) parts.push(`clear enemies ${run.enemiesRemaining}`);
            if (!okBoss) parts.push('defeat the boss');
            run.msg = 'Exit locked: ' + parts.join(' ¬∑ ');
          }
        }
      }
    }

    if (!key('Enter')) run._enterDown = false;

    // Particles
    for (const q of run.particles){
      q.x += q.vx*dt;
      q.y += q.vy*dt;
      q.vx *= (1 - dt*7);
      q.vy *= (1 - dt*7);
      q.life -= dt;
    }
    run.particles = run.particles.filter(q => q.life>0);

    // Remove dead
    run.ents = run.ents.filter(e => !e.dead);

    // If player died, convert to dead mode
    if (run.player.hp<=0 && run.mode==='play'){
      run.mode='dead';
      run.msg='You died. (Enter)';
    }

    // Camera follows player
    run.camX = lerp(run.camX, p.x - canvas.width/2, 0.12);
    run.camY = lerp(run.camY, p.y - canvas.height/2, 0.12);
    run.camX = clamp(run.camX, 0, MAP_W*TILE - canvas.width);
    run.camY = clamp(run.camY, 0, MAP_H*TILE - canvas.height);

    updateMetaUI();
  }

  function updateMetaUI(){
    metaEl.textContent = `Meta üí† ${meta.ornaments} | Skills: HP ${meta.skills.hp} ¬∑ DMG ${meta.skills.dmg} ¬∑ SPD ${meta.skills.spd} ¬∑ RLD ${meta.skills.reload} ¬∑ DASH ${meta.skills.dash}`;
  }

  // -----------------------------
  // Meta shop / between-runs screen
  // -----------------------------
  const SHOP_KEYS = ['hp','dmg','spd','reload','dash'];

  function stepShop(run, dt){
    // navigation
    if ((key('ArrowUp') || key('KeyW')) && !run._navUp){
      run._navUp=true;
      run.shopIndex = (run.shopIndex - 1 + SHOP_KEYS.length) % SHOP_KEYS.length;
    }
    if (!(key('ArrowUp')||key('KeyW'))) run._navUp=false;

    if ((key('ArrowDown') || key('KeyS')) && !run._navDown){
      run._navDown=true;
      run.shopIndex = (run.shopIndex + 1) % SHOP_KEYS.length;
    }
    if (!(key('ArrowDown')||key('KeyS'))) run._navDown=false;

    if (key('Enter') && !run._buyDown){
      run._buyDown=true;
      const k = SHOP_KEYS[run.shopIndex];
      const lv = meta.skills[k]||0;
      const info = SKILL_INFO[k];
      if (lv < info.max){
        const cost = info.cost(lv);
        if (meta.ornaments >= cost){
          meta.ornaments -= cost;
          meta.skills[k] = lv+1;
          saveMeta();
          updateMetaUI();
        }
      }
    }
    if (!key('Enter')) run._buyDown=false;

    if (key('KeyR') && !run._rDown){
      run._rDown=true;
      // Start a new run from scratch (fresh permadeath run)
      const newSeed = (Math.floor(Math.random()*1e9) ^ (meta.lastSeed||123456)) >>> 0;
      meta.lastSeed = newSeed;
      saveMeta();
      startNewRun(newSeed);
    }
    if (!key('KeyR')) run._rDown=false;

    // Also allow quick restart by Space
    if (key('Space') && !run._spaceDown){
      run._spaceDown=true;
      const newSeed = (Math.floor(Math.random()*1e9) ^ (meta.lastSeed||123456)) >>> 0;
      meta.lastSeed = newSeed;
      saveMeta();
      startNewRun(newSeed);
    }
    if (!key('Space')) run._spaceDown=false;
  }

  // -----------------------------
  // Rendering
  // -----------------------------
  function render(run){
    const world = run.world;
    const theme = world?.theme;

    ctx.clearRect(0,0,canvas.width, canvas.height);

    if (!run.world){
      ctx.fillStyle = '#d8e1ee';
      ctx.fillText('Loading world‚Ä¶', 20, 30);
      return;
    }

    // background
    ctx.fillStyle = '#070a0f';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    // map
    const camX = run.camX, camY = run.camY;
    const minTx = Math.floor(camX/TILE)-1;
    const minTy = Math.floor(camY/TILE)-1;
    const maxTx = Math.floor((camX+canvas.width)/TILE)+1;
    const maxTy = Math.floor((camY+canvas.height)/TILE)+1;

    for (let ty=minTy; ty<=maxTy; ty++){
      for (let tx=minTx; tx<=maxTx; tx++){
        if (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) continue;
        const t = tileAt(world, tx,ty);
        const x = tx*TILE - camX;
        const y = ty*TILE - camY;

        if (t===T.VOID){
          // nothing
        } else if (t===T.WALL){
          ctx.fillStyle = theme.wallColor;
          ctx.fillRect(x,y,TILE,TILE);
          // subtle highlight
          ctx.fillStyle = 'rgba(255,255,255,0.03)';
          ctx.fillRect(x,y,TILE,2);
        } else {
          if (t===T.FLOOR) ctx.fillStyle = theme.floorColor;
          if (t===T.RUG) ctx.fillStyle = 'rgba(214,59,59,0.22)';
          if (t===T.GOLD) ctx.fillStyle = 'rgba(255,213,106,0.18)';
          if (t===T.MARBLE) ctx.fillStyle = 'rgba(233,226,255,0.16)';
          if (t===T.DOOR) ctx.fillStyle = 'rgba(255,255,255,0.09)';
          ctx.fillRect(x,y,TILE,TILE);
        }
      }
    }

    // particles (behind entities)
    for (const q of run.particles){
      const x=q.x-camX, y=q.y-camY;
      ctx.fillStyle = 'rgba(255,255,255,' + clamp(q.life*5,0,1) + ')';
      ctx.fillRect(Math.floor(x), Math.floor(y), 2, 2);
    }

    // entities
    for (const e of run.ents){
      const x=e.x - camX;
      const y=e.y - camY;

      if (e.type===ENT.PLAYER || e.type===ENT.ENEMY || e.type===ENT.BOSS){
        const scale = e.type===ENT.BOSS ? 2 : 2;
        const px = Math.floor(x - (e.sprite.w*scale)/2);
        const py = Math.floor(y - (e.sprite.h*scale)/2);
        // invuln flicker
        if (e.type===ENT.PLAYER && e.invuln>0 && (Math.floor(run.time*20)%2===0)){
          ctx.globalAlpha = 0.35;
        }
        e.sprite.draw(px,py,scale,Math.floor(e.frame)%2,e.flip);
        ctx.globalAlpha = 1;

        // HP bars for boss
        if (e.type===ENT.BOSS){
          const w=200, h=10;
          const bx = canvas.width/2 - w/2, by = canvas.height - 40;
          ctx.fillStyle = 'rgba(0,0,0,0.55)';
          ctx.fillRect(bx,by,w,h);
          ctx.fillStyle = theme.accentColor;
          ctx.fillRect(bx,by,w*(e.hp/e.hpMax),h);
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.strokeRect(bx,by,w,h);
          // boss name
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px ui-monospace, monospace';
          ctx.textAlign = 'center';
          ctx.fillText(e.name || 'BOSS', bx+w/2, by-4);
          ctx.textAlign = 'start';
        }
      }

      if (e.type===ENT.DECOR){
         e.sprite.draw(Math.floor(x - (e.sprite.w)/2), Math.floor(y - (e.sprite.h)/2), 1, 0, false);
      }

      if (e.type===ENT.PRESENT){
        const scale=2;
        e.sprite.draw(Math.floor(x-(e.sprite.w*scale)/2), Math.floor(y-(e.sprite.h*scale)/2), scale, Math.floor(e.frame)%2, false);
      }

      if (e.type===ENT.POTION){
        const scale=2;
        e.sprite.draw(Math.floor(x-(e.sprite.w*scale)/2), Math.floor(y-(e.sprite.h*scale)/2), scale, 0, false);
      }

      if (e.type===ENT.CANDY){
        const scale=2;
        e.sprite.draw(Math.floor(x-(e.sprite.w*scale)/2), Math.floor(y-(e.sprite.h*scale)/2), scale, 0, false);
      }

      if (e.type===ENT.WEAPON){
        const scale=2;
        e.sprite.draw(Math.floor(x-(e.sprite.w*scale)/2), Math.floor(y-(e.sprite.h*scale)/2), scale, 0, false);
      }

      if (e.type===ENT.TREE){
        const scale=2;
        e.sprite.draw(Math.floor(x-(e.sprite.w*scale)/2), Math.floor(y-(e.sprite.h*scale)/2), scale, Math.floor(e.frame)%2, false);
        // glow
        ctx.fillStyle = 'rgba(255,213,106,0.10)';
        ctx.beginPath();
        ctx.arc(x,y,22+Math.sin(run.time*2)*2,0,Math.PI*2);
        ctx.fill();
      }

      if (e.type===ENT.PROP){
        e.sprite.draw(Math.floor(x-(e.sprite.w)/2), Math.floor(y-(e.sprite.h)/2), 1, 0, false);
      }

      if (e.type===ENT.ORNAMENT){
        ctx.fillStyle = 'rgba(138,213,255,0.9)';
        ctx.fillRect(Math.floor(x-2), Math.floor(y-2), 4, 4);
      }
    }

    // bullets
    for (const b of run.bullets){
      const x=b.x-camX, y=b.y-camY;
      ctx.fillStyle = (b.from===ENT.PLAYER) ? 'rgba(255,255,255,0.95)' : 'rgba(255,184,107,0.9)';
      ctx.fillRect(Math.floor(x-1), Math.floor(y-1), 2, 2);
    }

    // HUD
    const p = run.player;
    const hpW=180, hpH=8;
    const hx=16, hy=canvas.height-22;
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(hx,hy,hpW,hpH);
    ctx.fillStyle = 'rgba(214,59,59,0.95)';
    ctx.fillRect(hx,hy,hpW*clamp(p.hp/p.maxHp,0,1),hpH);
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.strokeRect(hx,hy,hpW,hpH);

    // dash charges
    const dx = hx + hpW + 12;
    for (let i=0;i<p.dash.maxCharges;i++){
      ctx.fillStyle = (i<p.dash.charges) ? 'rgba(138,213,255,0.95)' : 'rgba(138,213,255,0.20)';
      ctx.fillRect(dx+i*10, hy, 8, 8);
    }

    ctx.fillStyle = 'rgba(216,225,238,0.95)';
    ctx.font = '12px ui-monospace, monospace';
    ctx.fillText(`Level ${run.level} ‚Äî ${theme.name}`, 16, 18);
    const wName = (p.gun.kind||'pistol').toUpperCase();
    ctx.fillText(`üéÅ ${run.presentsTaken}/${run.presentsNeeded}  |  Enemies ${run.enemiesRemaining}  |  Boss ${run.bossAlive?'Alive':'Dead'}  |  Weapon: ${wName} (Q)`, 16, 36);

    // Aim indicator
    const ax = p.x + run.aimX*22 - camX;
    const ay = p.y + run.aimY*22 - camY;
    ctx.fillStyle = 'rgba(255,255,255,0.22)';
    ctx.beginPath();
    ctx.arc(ax,ay,6,0,Math.PI*2);
    ctx.fill();

    // Message
    if (run.msg){
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(14, canvas.height-56, canvas.width-28, 28);
      ctx.fillStyle = 'rgba(216,225,238,0.95)';
      ctx.fillText(run.msg, 24, canvas.height-37);
    }

    // Overlays
    if (run.paused){
      overlay('PAUSED', 'Press P to resume');
    }

    if (run.mode==='dead'){
      overlay('PERMA-DEATH', 'Press Enter to bank üí† and open Skill Tree');
    }

    if (run.mode==='win'){
      overlay('YOU WON', 'Press Enter to bank üí† and open Skill Tree');
    }

    if (run.mode==='between'){
      renderShop(run);
    }

    // top status
    statusEl.textContent = `${run.mode==='between' ? 'Skill Tree' : 'Run'} | Seed ${run.seed} | Level ${run.level} | ${run.paused ? 'Paused' : 'Active'}`;
  }

  function overlay(title, subtitle){
    ctx.fillStyle='rgba(0,0,0,0.62)';
    ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.fillStyle='rgba(216,225,238,0.95)';
    ctx.font='28px ui-monospace, monospace';
    ctx.fillText(title, 40, 120);
    ctx.font='14px ui-monospace, monospace';
    ctx.fillText(subtitle, 40, 150);
  }

  function renderShop(run){
    ctx.fillStyle='rgba(0,0,0,0.72)';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    ctx.fillStyle='rgba(216,225,238,0.95)';
    ctx.font='24px ui-monospace, monospace';
    ctx.fillText('Skill Tree (persistent across runs)', 40, 70);

    ctx.font='14px ui-monospace, monospace';
    ctx.fillText(`Meta currency: üí† ${meta.ornaments}`, 40, 96);
    ctx.fillText('Up/Down to select. Enter to buy. Press Space (or R) to start a NEW run.', 40, 116);

    const x=50, y=150;
    const rowH=44;

    for (let i=0;i<SHOP_KEYS.length;i++){
      const k = SHOP_KEYS[i];
      const info = SKILL_INFO[k];
      const lv = meta.skills[k]||0;
      const selected = (i===run.shopIndex);

      ctx.fillStyle = selected ? 'rgba(138,213,255,0.16)' : 'rgba(255,255,255,0.06)';
      ctx.fillRect(x, y+i*rowH, canvas.width-100, rowH-8);

      ctx.fillStyle = 'rgba(216,225,238,0.95)';
      ctx.font='16px ui-monospace, monospace';
      ctx.fillText(`${selected?'>':''} ${info.name}  (Lv ${lv}/${info.max})`, x+12, y+i*rowH+22);

      ctx.font='12px ui-monospace, monospace';
      ctx.fillStyle = 'rgba(155,176,201,0.95)';
      ctx.fillText(info.desc, x+12, y+i*rowH+38);

      const canUp = lv < info.max;
      const cost = canUp ? info.cost(lv) : null;
      const affordable = canUp && meta.ornaments>=cost;

      ctx.font='12px ui-monospace, monospace';
      ctx.fillStyle = canUp ? (affordable ? 'rgba(255,213,106,0.95)' : 'rgba(255,255,255,0.35)') : 'rgba(255,255,255,0.25)';
      ctx.fillText(canUp ? `Cost: üí† ${cost}` : 'MAXED', canvas.width-180, y+i*rowH+26);
    }

    // flavor text
    ctx.fillStyle='rgba(155,176,201,0.95)';
    ctx.font='12px ui-monospace, monospace';
    ctx.fillText('Lore: Every run you die, but the North Pole black market remembers your upgrades.', 40, canvas.height-48);
  }

  // -----------------------------
  // Boot
  // -----------------------------
  function boot(){
    // First seed: either meta last seed, or random
    const seed = (meta.lastSeed && Number.isFinite(meta.lastSeed)) ? (meta.lastSeed>>>0) : ((Math.random()*1e9)|0)>>>0;
    startNewRun(seed);
    update();
  }

  boot();

})();
</script>
</body>
</html>
